'use client';

import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Download, FileText, Package, Loader2 } from 'lucide-react';

interface DownloadGeneratedContentProps {
  htmlContent: string;
  filename?: string;
}

export default function DownloadGeneratedContent({ 
  htmlContent, 
  filename = 'generated-website' 
}: DownloadGeneratedContentProps) {
  const [isDownloading, setIsDownloading] = useState(false);
  const [downloadType, setDownloadType] = useState<'html' | 'zip' | null>(null);

  const captureGeneratedContent = (htmlString: string): string => {
    // Create a temporary DOM to process the HTML
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlString, 'text/html');
    
    // Remove generatetext.js script references
    const scripts = doc.querySelectorAll('script[src="/generatetext.js"]');
    scripts.forEach(script => script.remove());
    
    // Remove data-generatetext attributes
    const elementsWithData = doc.querySelectorAll('[data-generatetext]');
    elementsWithData.forEach(element => {
      element.removeAttribute('data-generatetext');
      element.removeAttribute('data-system');
    });
    
    // Remove loading states and animation classes
    const loadingElements = doc.querySelectorAll('.animate-pulse');
    loadingElements.forEach(element => {
      element.classList.remove('animate-pulse');
      // Remove loading text
      if (element.textContent?.includes('Loading')) {
        element.textContent = 'Content generated successfully';
      }
    });
    
    // Add generation timestamp comment
    const comment = doc.createComment(`
Generated by DeepSite - ${new Date().toISOString()}
This HTML contains AI-generated content and is ready for deployment.
All dynamic content has been converted to static content.
    `);
    doc.documentElement.insertBefore(comment, doc.documentElement.firstChild);
    
    return `<!DOCTYPE html>\n${doc.documentElement.outerHTML}`;
  };

  const downloadAsHTML = async () => {
    setIsDownloading(true);
    setDownloadType('html');
    
    try {
      const processedContent = captureGeneratedContent(htmlContent);
      const blob = new Blob([processedContent], { type: 'text/html;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = `${filename}.html`;
      link.style.display = 'none';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Failed to download HTML:', error);
      alert('Failed to download HTML file. Please try again.');
    } finally {
      setIsDownloading(false);
      setDownloadType(null);
    }
  };

  const extractImageUrls = (htmlString: string): string[] => {
    const imgRegex = /<img[^>]+src=["']([^"']+)["'][^>]*>/gi;
    const urls: string[] = [];
    let match;
    
    while ((match = imgRegex.exec(htmlString)) !== null) {
      urls.push(match[1]);
    }
    
    return [...new Set(urls)]; // Remove duplicates
  };

  const downloadImage = async (url: string): Promise<{ blob: Blob; filename: string } | null> => {
    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      
      const blob = await response.blob();
      const urlParts = url.split('/');
      const originalFilename = urlParts[urlParts.length - 1] || 'image';
      const extension = originalFilename.includes('.') 
        ? originalFilename.split('.').pop() 
        : 'jpg';
      
      return { blob, filename: `image-${Date.now()}.${extension}` };
    } catch (error) {
      console.warn(`Failed to download image: ${url}`, error);
      return null;
    }
  };

  const downloadAsZip = async () => {
    setIsDownloading(true);
    setDownloadType('zip');
    
    try {
      // Dynamic import for JSZip
      const JSZip = (await import('jszip')).default;
      const zip = new JSZip();
      
      const processedContent = captureGeneratedContent(htmlContent);
      const imageUrls = extractImageUrls(processedContent);
      const imageMap = new Map<string, string>();
      
      // Download all images
      console.log(`Found ${imageUrls.length} images to download`);
      const imagePromises = imageUrls.map(async (url, index) => {
        const result = await downloadImage(url);
        if (result) {
          const localFilename = `images/${result.filename}`;
          zip.file(localFilename, result.blob);
          imageMap.set(url, localFilename);
          return { url, localFilename };
        }
        return null;
      });
      
      await Promise.all(imagePromises);
      
      // Replace image URLs in HTML with local paths
      let updatedHtml = processedContent;
      imageMap.forEach((localPath, originalUrl) => {
        updatedHtml = updatedHtml.replace(new RegExp(originalUrl.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), localPath);
      });
      
      // Add the main HTML file
      zip.file(`${filename}.html`, updatedHtml);
      
      // Add a README file
      const readme = `# Generated Website Package

This package contains your AI-generated website with all assets.

## Contents:
- ${filename}.html - Your main website file
- images/ - All images used in the website (${imageMap.size} files)

## How to Use:
1. Extract all files to a folder
2. Open ${filename}.html in any web browser
3. All images are included and will work offline

## Deployment:
- Upload all files to your web hosting service
- Ensure folder structure is maintained
- The website will work immediately

Generated by DeepSite on ${new Date().toLocaleString()}
Website URL: http://localhost:3001
`;
      
      zip.file('README.md', readme);
      
      // Generate and download the ZIP
      const zipBlob = await zip.generateAsync({ 
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 }
      });
      
      const url = URL.createObjectURL(zipBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${filename}.zip`;
      link.style.display = 'none';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      URL.revokeObjectURL(url);
      
      console.log(`ZIP package created with ${imageMap.size} images`);
    } catch (error) {
      console.error('Failed to create ZIP package:', error);
      alert('Failed to create ZIP package. Please try downloading HTML only.');
    } finally {
      setIsDownloading(false);
      setDownloadType(null);
    }
  };

  const isProcessableContent = htmlContent && htmlContent.includes('<!DOCTYPE html');

  if (!isProcessableContent) {
    return (
      <div className="flex items-center gap-2 text-gray-500">
        <FileText className="w-4 h-4" />
        <span className="text-sm">Generate content first to enable downloads</span>
      </div>
    );
  }

  return (
    <div className="flex items-center gap-2">
      <Button
        onClick={downloadAsHTML}
        disabled={isDownloading}
        variant="outline"
        size="sm"
        className="flex items-center gap-2"
      >
        {isDownloading && downloadType === 'html' ? (
          <Loader2 className="w-4 h-4 animate-spin" />
        ) : (
          <FileText className="w-4 h-4" />
        )}
        Download HTML
      </Button>
      
      <Button
        onClick={downloadAsZip}
        disabled={isDownloading}
        variant="outline"
        size="sm"
        className="flex items-center gap-2"
      >
        {isDownloading && downloadType === 'zip' ? (
          <Loader2 className="w-4 h-4 animate-spin" />
        ) : (
          <Package className="w-4 h-4" />
        )}
        Download ZIP
      </Button>
      
      {isDownloading && (
        <span className="text-sm text-gray-600">
          {downloadType === 'zip' ? 'Creating package...' : 'Preparing download...'}
        </span>
      )}
    </div>
  );
}
